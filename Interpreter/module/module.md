# module

### contents

* [related file](#related-file)
* [memory layout](#memory-layout)
* [example](#example)
* [how to debug import](#how-to-debug-import)
* [how does import work](#how-does-import-work)

#### related file

* cpython/Objects/moduleobject.c
* cpython/Include/moduleobject.h
* cpython/Objects/clinic/moduleobject.c.h
* cpython/Python/import.c
* cpython/Python/clinic/import.c.h
* cpython/Lib/importlib/_bootstrap.py

#### memory layout

there's a struct named **PyModuleDef** defined in `Include/moduleobject.h`

![layout_PyModuleDef](https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/module/layout_PyModuleDef.png)

the **PyModuleObject** is defined in `Objects/moduleobject.c`, which contains a field with type **PyModuleDef**

![layout_PyModuleObject](https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/module/layout_PyModuleObject.png)

#### example

the field **md_dict** is the `__dict__` attribute of the module object

**PyModuleDef** is optional, the index located in the m_base field is used for find the module by index in sys.modules, not by name

**m_size** stores the size of per-module data

**m_clear** and **m_free** are used for deallolcation

for more detail please refer to [PEP 3121 -- Extension Module Initialization and Finalization](https://www.python.org/dev/peps/pep-3121/)

    import _locale

![locale](https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/module/locale.png)

    import re

![re](https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/module/re.png)

#### how to debug import

when you try to look into the source code to find out how `import` works

follow the call stack

![import_call_stack](https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/module/import_call_stack.png)

the core callable object is `interp->importlib` which is initialized in

    /* cpython/Python/pylifecycle.c */
    static _PyInitError
    initimport(PyInterpreterState *interp, PyObject *sysmod)
    {
        /* omit */
        importlib = PyImport_AddModule("_frozen_importlib");
        if (importlib == NULL) {
            return _Py_INIT_ERR("couldn't get _frozen_importlib from sys.modules");
        }
        interp->importlib = importlib;
        Py_INCREF(interp->importlib);
        /* omit */
    }

search the `_frozen_importlib`, you can find the half-binary file `Python/importlib.h` with content

    /* Auto-generated by Programs/_freeze_importlib.c */
    const unsigned char _Py_M__importlib_bootstrap[] = {
        99,0,0,0,0,0,0,0,0,0,0,0,0,4,0,0,
        ...
    }
    */

it turns out that `_freeze_importlib.c` will freeze the python code in `Lib/importlib/_bootstrap.py` to the half-binary format`Python/importlib.h`

![importlib](https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/module/importlib.png)

it's interesting that the `import` procedure is actually written in pure python, the attribute `PyId__find_and_load` of `interp->importlib` maps to the python function name `_find_and_load` defined in `Lib/importlib/_bootstrap.py`

whenever you modify the source code in `Lib/importlib/_bootstrap.py`, you need to regenerate the `Python/importlib.h` file, and recompile the source code

	# compile ./Programs/_freeze_importlib.c, and use the program to freeze
    # _bootstrap_external.py -> importlib_external.h
    # _bootstrap.py -> importlib.h
    # zipimport.py -> importlib_zipimport.h
	make regen-importlib
    # recompile
    make

#### how does import work

let's compile a script with only one line `import _locale`

    ./python.exe -m dis test.py
    1           0 LOAD_CONST               0 (0)
              2 LOAD_CONST               1 (None)
              4 IMPORT_NAME              0 (_locale)
              6 STORE_NAME               0 (_locale)
              8 LOAD_CONST               1 (None)
             10 RETURN_VALUE

the core opcde here is `IMPORT_NAME`

it's tedious to copy and paste all the source code related to `IMPORT_NAME`, even with annotation

imagine that there're two or more threads currently importing the same `_locale` module, how does CPython handle this situation ?

if you read the source code and following images, you will notice that the lock mechanism is used for preventing race condition

the procedures are shown

1. opcode `IMPORT_NAME` will checks if the name being imported is in sys.module, if so return what's in the sys.module
2. try to acquire the lock `_imp`
3. get the lock object in `_module_locks` with module name, create if necessary(in `position 1`)
4. try to acquire the lock object in step 3 (in `position 2`)
5. release the lock `_imp`

in `position 1`, only thread holds `_imp` can modify the `_module_locks`, the current thread will check if the module name being imported is in `_module_locks`, if not, insert a new lock object into `_module_locks`

in `position 3`, lock `_imp` is released, if there're other thread importing other module, it's able to acquire the `_imp` lock and continue the procedure, if there's other thread importing the same module, even if it acquire `_imp` successfully, it will fail in acquiring the lock in `_module_locks`, since the previous thread is holding it

![import procedure1](https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/module/import%20procedure1.png)


![import procedure2](https://github.com/zpoint/CPython-Internals/blob/master/Interpreter/module/import%20procedure2.png)